.class public abstract Lph1;
.super Lxe1;
.source "NumericFunction.java"


# annotations
.annotation system Ldalvik/annotation/MemberClasses;
    value = {
        Lph1$s0;,
        Lph1$u0;,
        Lph1$t0;
    }
.end annotation


# static fields
.field public static final A:Lue1;

.field public static final B:Lue1;

.field public static final C:Lue1;

.field public static final D:Lue1;

.field public static final E:Lue1;

.field public static final F:Lue1;

.field public static final G:Lue1;

.field public static final H:Lue1;

.field public static final I:Lue1;

.field public static final J:Lue1;

.field public static final K:Lue1;

.field public static final L:Lue1;

.field public static final M:Lue1;

.field public static final N:Lue1;

.field public static final O:Lue1;

.field public static final P:Lue1;

.field public static final Q:Lue1;

.field public static final R:Luc1;

.field public static final S:Lue1;

.field public static final T:Lue1;

.field public static final U:Lue1;

.field public static final V:Lue1;

.field public static final a:Luc1;

.field public static final b:D

.field public static final c:Lue1;

.field public static final d:Lue1;

.field public static final e:Lue1;

.field public static final f:Lue1;

.field public static final g:Lue1;

.field public static final h:Lue1;

.field public static final i:Lue1;

.field public static final j:Lue1;

.field public static final k:Lue1;

.field public static final l:Lue1;

.field public static final m:Lue1;

.field public static final n:Lue1;

.field public static final o:Lue1;

.field public static final p:Lue1;

.field public static final q:Lue1;

.field public static final r:Lue1;

.field public static final s:Lue1;

.field public static final t:Lue1;

.field public static final u:Lue1;

.field public static final v:Lue1;

.field public static final w:Lue1;

.field public static final x:Lue1;

.field public static final y:Lue1;

.field public static final z:Lue1;


# direct methods
.method public static constructor <clinit>()V
    .locals 3

    .line 1
    new-instance v0, Luc1;

    const-wide/16 v1, 0x0

    invoke-direct {v0, v1, v2}, Luc1;-><init>(D)V

    sput-object v0, Lph1;->a:Luc1;

    const-wide/high16 v0, 0x4024000000000000L    # 10.0

    .line 2
    invoke-static {v0, v1}, Ljava/lang/Math;->log(D)D

    move-result-wide v0

    sput-wide v0, Lph1;->b:D

    .line 3
    new-instance v0, Lph1$k;

    invoke-direct {v0}, Lph1$k;-><init>()V

    sput-object v0, Lph1;->c:Lue1;

    .line 4
    new-instance v0, Lph1$c;

    invoke-direct {v0}, Lph1$c;-><init>()V

    sput-object v0, Lph1;->d:Lue1;

    .line 5
    new-instance v0, Lph1$o;

    invoke-direct {v0}, Lph1$o;-><init>()V

    sput-object v0, Lph1;->e:Lue1;

    .line 6
    new-instance v0, Lph1$a0;

    invoke-direct {v0}, Lph1$a0;-><init>()V

    sput-object v0, Lph1;->f:Lue1;

    .line 7
    new-instance v0, Lph1$h0;

    invoke-direct {v0}, Lph1$h0;-><init>()V

    sput-object v0, Lph1;->g:Lue1;

    .line 8
    new-instance v0, Lph1$i0;

    invoke-direct {v0}, Lph1$i0;-><init>()V

    sput-object v0, Lph1;->h:Lue1;

    .line 9
    new-instance v0, Lph1$j0;

    invoke-direct {v0}, Lph1$j0;-><init>()V

    sput-object v0, Lph1;->i:Lue1;

    .line 10
    new-instance v0, Lph1$k0;

    invoke-direct {v0}, Lph1$k0;-><init>()V

    sput-object v0, Lph1;->j:Lue1;

    .line 11
    new-instance v0, Lph1$l0;

    invoke-direct {v0}, Lph1$l0;-><init>()V

    sput-object v0, Lph1;->k:Lue1;

    .line 12
    new-instance v0, Lph1$v;

    invoke-direct {v0}, Lph1$v;-><init>()V

    sput-object v0, Lph1;->l:Lue1;

    .line 13
    new-instance v0, Lph1$g0;

    invoke-direct {v0}, Lph1$g0;-><init>()V

    sput-object v0, Lph1;->m:Lue1;

    .line 14
    new-instance v0, Lph1$m0;

    invoke-direct {v0}, Lph1$m0;-><init>()V

    sput-object v0, Lph1;->n:Lue1;

    .line 15
    new-instance v0, Lph1$n0;

    invoke-direct {v0}, Lph1$n0;-><init>()V

    sput-object v0, Lph1;->o:Lue1;

    .line 16
    new-instance v0, Lph1$o0;

    invoke-direct {v0}, Lph1$o0;-><init>()V

    sput-object v0, Lph1;->p:Lue1;

    .line 17
    new-instance v0, Lph1$p0;

    invoke-direct {v0}, Lph1$p0;-><init>()V

    sput-object v0, Lph1;->q:Lue1;

    .line 18
    new-instance v0, Lph1$q0;

    invoke-direct {v0}, Lph1$q0;-><init>()V

    sput-object v0, Lph1;->r:Lue1;

    .line 19
    new-instance v0, Lph1$r0;

    invoke-direct {v0}, Lph1$r0;-><init>()V

    sput-object v0, Lph1;->s:Lue1;

    .line 20
    new-instance v0, Lph1$a;

    invoke-direct {v0}, Lph1$a;-><init>()V

    sput-object v0, Lph1;->t:Lue1;

    .line 21
    new-instance v0, Lph1$b;

    invoke-direct {v0}, Lph1$b;-><init>()V

    sput-object v0, Lph1;->u:Lue1;

    .line 22
    new-instance v0, Lph1$d;

    invoke-direct {v0}, Lph1$d;-><init>()V

    sput-object v0, Lph1;->v:Lue1;

    .line 23
    new-instance v0, Lph1$e;

    invoke-direct {v0}, Lph1$e;-><init>()V

    sput-object v0, Lph1;->w:Lue1;

    .line 24
    new-instance v0, Lph1$f;

    invoke-direct {v0}, Lph1$f;-><init>()V

    sput-object v0, Lph1;->x:Lue1;

    .line 25
    new-instance v0, Lph1$g;

    invoke-direct {v0}, Lph1$g;-><init>()V

    sput-object v0, Lph1;->y:Lue1;

    .line 26
    new-instance v0, Lph1$h;

    invoke-direct {v0}, Lph1$h;-><init>()V

    sput-object v0, Lph1;->z:Lue1;

    .line 27
    new-instance v0, Lph1$i;

    invoke-direct {v0}, Lph1$i;-><init>()V

    sput-object v0, Lph1;->A:Lue1;

    .line 28
    new-instance v0, Lph1$j;

    invoke-direct {v0}, Lph1$j;-><init>()V

    sput-object v0, Lph1;->B:Lue1;

    .line 29
    new-instance v0, Lph1$l;

    invoke-direct {v0}, Lph1$l;-><init>()V

    sput-object v0, Lph1;->C:Lue1;

    .line 30
    new-instance v0, Lph1$m;

    invoke-direct {v0}, Lph1$m;-><init>()V

    sput-object v0, Lph1;->D:Lue1;

    .line 31
    new-instance v0, Lph1$n;

    invoke-direct {v0}, Lph1$n;-><init>()V

    sput-object v0, Lph1;->E:Lue1;

    .line 32
    new-instance v0, Lph1$p;

    invoke-direct {v0}, Lph1$p;-><init>()V

    sput-object v0, Lph1;->F:Lue1;

    .line 33
    new-instance v0, Lph1$q;

    invoke-direct {v0}, Lph1$q;-><init>()V

    sput-object v0, Lph1;->G:Lue1;

    .line 34
    new-instance v0, Lph1$r;

    invoke-direct {v0}, Lph1$r;-><init>()V

    sput-object v0, Lph1;->H:Lue1;

    .line 35
    new-instance v0, Lph1$s;

    invoke-direct {v0}, Lph1$s;-><init>()V

    sput-object v0, Lph1;->I:Lue1;

    .line 36
    new-instance v0, Lph1$t;

    invoke-direct {v0}, Lph1$t;-><init>()V

    sput-object v0, Lph1;->J:Lue1;

    .line 37
    new-instance v0, Lph1$u;

    invoke-direct {v0}, Lph1$u;-><init>()V

    sput-object v0, Lph1;->K:Lue1;

    .line 38
    new-instance v0, Lph1$w;

    invoke-direct {v0}, Lph1$w;-><init>()V

    sput-object v0, Lph1;->L:Lue1;

    .line 39
    new-instance v0, Lph1$x;

    invoke-direct {v0}, Lph1$x;-><init>()V

    sput-object v0, Lph1;->M:Lue1;

    .line 40
    new-instance v0, Lph1$y;

    invoke-direct {v0}, Lph1$y;-><init>()V

    sput-object v0, Lph1;->N:Lue1;

    .line 41
    new-instance v0, Lph1$z;

    invoke-direct {v0}, Lph1$z;-><init>()V

    sput-object v0, Lph1;->O:Lue1;

    .line 42
    new-instance v0, Lph1$b0;

    invoke-direct {v0}, Lph1$b0;-><init>()V

    sput-object v0, Lph1;->P:Lue1;

    .line 43
    new-instance v0, Lph1$s0;

    invoke-direct {v0}, Lph1$s0;-><init>()V

    sput-object v0, Lph1;->Q:Lue1;

    .line 44
    new-instance v0, Luc1;

    const-wide v1, 0x400921fb54442d18L    # Math.PI

    invoke-direct {v0, v1, v2}, Luc1;-><init>(D)V

    sput-object v0, Lph1;->R:Luc1;

    .line 45
    new-instance v0, Lph1$c0;

    invoke-direct {v0}, Lph1$c0;-><init>()V

    sput-object v0, Lph1;->S:Lue1;

    .line 46
    new-instance v0, Lph1$d0;

    invoke-direct {v0}, Lph1$d0;-><init>()V

    sput-object v0, Lph1;->T:Lue1;

    .line 47
    new-instance v0, Lph1$e0;

    invoke-direct {v0}, Lph1$e0;-><init>()V

    sput-object v0, Lph1;->U:Lue1;

    .line 48
    new-instance v0, Lph1$f0;

    invoke-direct {v0}, Lph1$f0;-><init>()V

    sput-object v0, Lph1;->V:Lue1;

    return-void
.end method

.method public constructor <init>()V
    .locals 0

    .line 1
    invoke-direct {p0}, Lxe1;-><init>()V

    return-void
.end method

.method public static final e(D)V
    .locals 1
    .annotation system Ldalvik/annotation/Throws;
        value = {
            Lpd1;
        }
    .end annotation

    .line 1
    invoke-static {p0, p1}, Ljava/lang/Double;->isNaN(D)Z

    move-result v0

    if-nez v0, :cond_0

    invoke-static {p0, p1}, Ljava/lang/Double;->isInfinite(D)Z

    move-result p0

    if-nez p0, :cond_0

    return-void

    .line 2
    :cond_0
    sget-object p0, Lpd1;->W:Lpd1;

    throw p0
.end method

.method public static final f(Lhd1;Lsd1;)D
    .locals 0
    .annotation system Ldalvik/annotation/Throws;
        value = {
            Lpd1;
        }
    .end annotation

    if-eqz p0, :cond_0

    .line 1
    invoke-static {p0, p1}, Lld1;->g(Lhd1;Lsd1;)Lhd1;

    move-result-object p0

    .line 2
    invoke-static {p0}, Lld1;->f(Lhd1;)D

    move-result-wide p0

    .line 3
    invoke-static {p0, p1}, Lph1;->e(D)V

    return-wide p0

    .line 4
    :cond_0
    new-instance p0, Ljava/lang/IllegalArgumentException;

    const-string p1, "arg must not be null"

    invoke-direct {p0, p1}, Ljava/lang/IllegalArgumentException;-><init>(Ljava/lang/String;)V

    throw p0
.end method


# virtual methods
.method public final c(B[Lhd1;Lsd1;)Lhd1;
    .locals 0

    .line 1
    :try_start_0
    invoke-virtual {p0, p2, p3}, Lph1;->d([Lhd1;Lsd1;)D

    move-result-wide p1

    .line 2
    invoke-static {p1, p2}, Lph1;->e(D)V
    :try_end_0
    .catch Lpd1; {:try_start_0 .. :try_end_0} :catch_0

    .line 3
    new-instance p3, Luc1;

    invoke-direct {p3, p1, p2}, Luc1;-><init>(D)V

    return-object p3

    :catch_0
    move-exception p1

    .line 4
    invoke-virtual {p1}, Lpd1;->a()Lbd1;

    move-result-object p1

    return-object p1
.end method

.method public abstract d([Lhd1;Lsd1;)D
    .annotation system Ldalvik/annotation/Throws;
        value = {
            Lpd1;
        }
    .end annotation
.end method
